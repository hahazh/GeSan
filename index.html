# import pygame
# import sys
# import math
# import os

# # --- 1. 初始化和常量 (Initialization and Constants) ---

# # Pygame 初始化
# pygame.init()
# pygame.font.init()

# # 屏幕设置 (使用小尺寸)
# SCREEN_WIDTH = 640
# SCREEN_HEIGHT = 740
# screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
# pygame.display.set_caption("搁彡 (Diagonal Rules)")

# # 颜色
# COLOR_BOARD = (210, 180, 140)
# COLOR_BG = (245, 245, 220)
# COLOR_LINE = (0, 0, 0)
# COLOR_PLAYER1 = (255, 255, 255)
# COLOR_PLAYER2 = (0, 0, 0)
# COLOR_HIGHLIGHT = (255, 0, 0)
# COLOR_TEXT = (50, 50, 50)

# # --- 【新增】字体处理 (Font Handling) ---
# FONT_CN_PATH = "simhei.ttf" # 默认字体文件名
# # 尝试在系统路径（主要针对Windows）中寻找字体
# if sys.platform == "win32":
#     font_path_system = os.path.join(os.environ.get("SystemRoot", "C:/Windows"), "Fonts", FONT_CN_PATH)
#     if os.path.exists(font_path_system):
#         FONT_CN_PATH = font_path_system

# try:
#     FONT_STATUS_CN = pygame.font.Font(FONT_CN_PATH, 26)
#     FONT_INFO_CN = pygame.font.Font(FONT_CN_PATH, 20)
# except FileNotFoundError:
#     print(f"错误：中文字体 '{FONT_CN_PATH}' 未找到！")
#     print("请下载一个中文字体 (如 simhei.ttf) 并与游戏文件放在同一目录下。")
#     # 使用一个备用英文字体，防止程序崩溃
#     FONT_STATUS_CN = pygame.font.SysFont('Arial', 30)
#     FONT_INFO_CN = pygame.font.SysFont('Arial', 24)


# # 游戏常量
# PIECE_RADIUS = 16
# CLICK_RADIUS = 25

# # --- 2. 游戏规则数据结构 (保持不变) ---
# POSITIONS = [
#     'O1', 'O2', 'O3', 'O4', 'O5', 'O6', 'O7', 'O8', 'M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'M8',
#     'I1', 'I2', 'I3', 'I4', 'I5', 'I6', 'I7', 'I8',
# ]
# COORDS = {
#     'O1': (70, 70), 'O2': (320, 70), 'O3': (570, 70), 'O4': (570, 320), 'O5': (570, 570), 'O6': (320, 570),
#     'O7': (70, 570), 'O8': (70, 320), 'M1': (170, 170), 'M2': (320, 170), 'M3': (470, 170), 'M4': (470, 320),
#     'M5': (470, 470), 'M6': (320, 470), 'M7': (170, 470), 'M8': (170, 320), 'I1': (250, 250), 'I2': (320, 250),
#     'I3': (390, 250), 'I4': (390, 320), 'I5': (390, 390), 'I6': (320, 390), 'I7': (250, 390), 'I8': (250, 320),
# }
# ADJACENCY = {
#     'O1': ['O2', 'O8', 'M1'], 'O2': ['O1', 'O3', 'M2'], 'O3': ['O2', 'O4', 'M3'], 'O4': ['O3', 'O5', 'M4'],
#     'O5': ['O4', 'O6', 'M5'], 'O6': ['O5', 'O7', 'M6'], 'O7': ['O6', 'O8', 'M7'], 'O8': ['O7', 'O1', 'M8'],
#     'M1': ['M2', 'M8', 'O1', 'I1'], 'M2': ['M1', 'M3', 'O2', 'I2'], 'M3': ['M2', 'M4', 'O3', 'I3'],
#     'M4': ['M3', 'M5', 'O4', 'I4'], 'M5': ['M4', 'M6', 'O5', 'I5'], 'M6': ['M5', 'M7', 'O6', 'I6'],
#     'M7': ['M6', 'M8', 'O7', 'I7'], 'M8': ['M7', 'M1', 'O8', 'I8'], 'I1': ['I2', 'I8', 'M1'],
#     'I2': ['I1', 'I3', 'M2'], 'I3': ['I2', 'I4', 'M3'], 'I4': ['I3', 'I5', 'M4'], 'I5': ['I4', 'I6', 'M5'],
#     'I6': ['I5', 'I7', 'M6'], 'I7': ['I6', 'I8', 'M7'], 'I8': ['I7', 'I1', 'M8']
# }
# MILLS = [
#     ['O1', 'O2', 'O3'], ['O3', 'O4', 'O5'], ['O5', 'O6', 'O7'], ['O7', 'O8', 'O1'], ['M1', 'M2', 'M3'],
#     ['M3', 'M4', 'M5'], ['M5', 'M6', 'M7'], ['M7', 'M8', 'M1'], ['I1', 'I2', 'I3'], ['I3', 'I4', 'I5'],
#     ['I5', 'I6', 'I7'], ['I7', 'I8', 'I1'], ['O2', 'M2', 'I2'], ['O4', 'M4', 'I4'], ['O6', 'M6', 'I6'],
#     ['O8', 'M8', 'I8'], ['O1', 'M1', 'I1'], ['O3', 'M3', 'I3'], ['O5', 'M5', 'I5'], ['O7', 'M7', 'I7']
# ]


# # --- 3. 游戏主类 (Main Game Class) ---

# class Game:
#     def __init__(self):
#         self.board = {pos: 0 for pos in POSITIONS}
#         self.phase = 1
#         self.turn = 1
#         self.pieces_to_place = {1: 12, 2: 12}
#         self.game_state = "place"
#         self.selected_piece_pos = None
#         self.message = ""
#         self.newly_formed_mill = []
#         self.clock = pygame.time.Clock()
#         self.update_message()

#     def get_piece_counts(self):
#         p1_count = sum(1 for v in self.board.values() if v == 1)
#         p2_count = sum(1 for v in self.board.values() if v == 2)
#         return p1_count, p2_count

#     # 【修改】完全中文化的提示信息更新
#     def update_message(self):
#         player_name = f"白方 (玩家1)" if self.turn == 1 else f"黑方 (玩家2)"
#         if self.game_state == "place":
#             self.message = f"轮到{player_name}: 请放置棋子。剩余: {self.pieces_to_place[self.turn]}"
#         elif self.game_state == "remove":
#             self.message = f"{player_name}三连已成！请选择一个对方棋子进行“薅”子！"
#         elif self.game_state == "move_select":
#             self.message = f"轮到{player_name}: 请选择要移动的己方棋子。"
#         elif self.game_state == "move_place":
#             self.message = f"轮到{player_name}: 请选择一个相邻的空位。"
#         elif self.game_state == "game_over":
#             winner_name = "白方 (玩家1)" if self.turn == 2 else "黑方 (玩家2)"
#             self.message = f"游戏结束！{winner_name}胜利！按 'R' 重新开始。"

#     # (其余函数保持不变，无需修改)
#     def switch_turn(self):
#         self.turn = 3 - self.turn
#         self.newly_formed_mill = []
#         if self.phase == 1 and all(p == 0 for p in self.pieces_to_place.values()):
#             self.phase = 2
#             for pos, val in self.board.items():
#                 if val == -1: self.board[pos] = 0
#             self.turn = 2
#             self.game_state = "move_select"
#         elif self.phase == 2:
#              if self.check_win_condition(): return
#              if self.check_stalemate():
#                  winner_name = "白方" if self.turn == 2 else "黑方"
#                  self.game_state = "game_over"
#                  self.message = f"游戏结束！{winner_name}胜利 (对手已无路可走)！按 'R' 重新开始。"
#                  return
#         self.update_message()
    
#     def get_pos_from_mouse(self, mouse_pos):
#         for pos_id, coord in COORDS.items():
#             if math.hypot(mouse_pos[0] - coord[0], mouse_pos[1] - coord[1]) <= CLICK_RADIUS:
#                 return pos_id
#         return None

#     def check_mill(self, pos, player):
#         for mill in MILLS:
#             if pos in mill and all(self.board.get(p) == player for p in mill):
#                 if sorted(mill) not in self.newly_formed_mill:
#                     self.newly_formed_mill.append(sorted(mill))
#                     return True
#         return False

#     def is_in_a_mill(self, pos):
#         player = self.board[pos]
#         if player == 0: return False
#         for mill in MILLS:
#             if pos in mill and all(self.board.get(p) == player for p in mill):
#                 return True
#         return False
        
#     def check_win_condition(self):
#         p1_count, p2_count = self.get_piece_counts()
#         opponent_pieces = p2_count if self.turn == 1 else p1_count
#         if self.phase == 2 and opponent_pieces < 3:
#             self.game_state = "game_over"
#             self.update_message()
#             return True
#         return False
    
#     def check_stalemate(self):
#         if self.phase != 2: return False
#         for pos, player in self.board.items():
#             if player == self.turn:
#                 for neighbor in ADJACENCY[pos]:
#                     if self.board[neighbor] == 0:
#                         return False
#         return True

#     def has_valid_capture_target(self):
#         opponent = 3 - self.turn
#         for piece_pos, owner in self.board.items():
#             if owner == opponent and not self.is_in_a_mill(piece_pos):
#                 return True
#         return False

#     def handle_click(self, pos_id):
#         if not pos_id: return
#         if self.game_state == "place":
#             if self.board[pos_id] == 0:
#                 self.board[pos_id] = self.turn
#                 self.pieces_to_place[self.turn] -= 1
#                 if self.check_mill(pos_id, self.turn):
#                     if self.has_valid_capture_target():
#                         self.game_state = "remove"
#                     else:
#                         self.switch_turn()
#                 else:
#                     self.switch_turn()
#                 self.update_message()
#         elif self.game_state == "remove":
#             opponent = 3 - self.turn
#             if self.board.get(pos_id) == opponent:
#                 if not self.is_in_a_mill(pos_id):
#                     self.board[pos_id] = -1 if self.phase == 1 else 0
#                     if not self.check_win_condition():
#                          self.game_state = "place" if self.phase == 1 else "move_select"
#                          self.switch_turn()
#                     self.update_message()
#         elif self.game_state == "move_select":
#             if self.board[pos_id] == self.turn:
#                 self.selected_piece_pos = pos_id
#                 self.game_state = "move_place"
#                 self.update_message()
#         elif self.game_state == "move_place":
#             if self.board[pos_id] == self.turn:
#                 self.selected_piece_pos = pos_id
#                 self.update_message()
#             elif self.board[pos_id] == 0 and pos_id in ADJACENCY[self.selected_piece_pos]:
#                 self.board[self.selected_piece_pos] = 0
#                 self.board[pos_id] = self.turn
#                 if self.check_mill(pos_id, self.turn):
#                     if self.has_valid_capture_target():
#                         self.game_state = "remove"
#                     else:
#                         self.switch_turn()
#                 else:
#                     self.switch_turn()
#                 self.selected_piece_pos = None
#                 self.update_message()
#             else:
#                  self.selected_piece_pos = None
#                  self.game_state = "move_select"
#                  self.update_message()

#     def draw_board(self):
#         screen.fill(COLOR_BG)
#         pygame.draw.rect(screen, COLOR_BOARD, (20, 20, 600, 600))
#         pygame.draw.rect(screen, COLOR_LINE, (70, 70, 500, 500), 4)
#         pygame.draw.rect(screen, COLOR_LINE, (170, 170, 300, 300), 4)
#         pygame.draw.rect(screen, COLOR_LINE, (250, 250, 140, 140), 4)
#         pygame.draw.line(screen, COLOR_LINE, COORDS['O2'], COORDS['I2'], 4)
#         pygame.draw.line(screen, COLOR_LINE, COORDS['O4'], COORDS['I4'], 4)
#         pygame.draw.line(screen, COLOR_LINE, COORDS['O6'], COORDS['I6'], 4)
#         pygame.draw.line(screen, COLOR_LINE, COORDS['O8'], COORDS['I8'], 4)
#         pygame.draw.line(screen, COLOR_LINE, COORDS['O1'], COORDS['I1'], 4)
#         pygame.draw.line(screen, COLOR_LINE, COORDS['O3'], COORDS['I3'], 4)
#         pygame.draw.line(screen, COLOR_LINE, COORDS['O5'], COORDS['I5'], 4)
#         pygame.draw.line(screen, COLOR_LINE, COORDS['O7'], COORDS['I7'], 4)

#     def draw_pieces(self):
#         for pos_id, coord in COORDS.items():
#             player = self.board[pos_id]
#             if player == 1:
#                 pygame.draw.circle(screen, COLOR_PLAYER1, coord, PIECE_RADIUS)
#             elif player == 2:
#                 pygame.draw.circle(screen, COLOR_PLAYER2, coord, PIECE_RADIUS)
#             elif player == -1:
#                 pygame.draw.line(screen, COLOR_HIGHLIGHT, (coord[0]-10, coord[1]-10), (coord[0]+10, coord[1]+10), 4)
#                 pygame.draw.line(screen, COLOR_HIGHLIGHT, (coord[0]+10, coord[1]-10), (coord[0]-10, coord[1]+10), 4)
#             if self.selected_piece_pos == pos_id:
#                 pygame.draw.circle(screen, COLOR_HIGHLIGHT, coord, PIECE_RADIUS + 4, 4)

#     # 【修改】重新排版的状态面板，使用中文字体
#     def draw_status_panel(self):
#         # 绘制底部面板背景
#         pygame.draw.rect(screen, COLOR_BOARD, (0, 640, SCREEN_WIDTH, 100))
        
#         # 1. 绘制主要状态信息 (居中)
#         text_surface = FONT_STATUS_CN.render(self.message, True, COLOR_TEXT)
#         text_rect = text_surface.get_rect(center=(SCREEN_WIDTH / 2, 670)) # 靠上一点
#         screen.blit(text_surface, text_rect)

#         # 2. 绘制玩家棋子信息
#         p1_count, p2_count = self.get_piece_counts()
        
#         # 玩家1信息 (左对齐)
#         p1_info = f"白方棋子: {p1_count}"
#         p1_surf = FONT_INFO_CN.render(p1_info, True, COLOR_TEXT)
#         p1_rect = p1_surf.get_rect(midleft=(25, 710))
#         screen.blit(p1_surf, p1_rect)
        
#         # 玩家2信息 (右对齐)
#         p2_info = f"黑方棋子: {p2_count}"
#         p2_surf = FONT_INFO_CN.render(p2_info, True, COLOR_TEXT)
#         p2_rect = p2_surf.get_rect(midright=(SCREEN_WIDTH - 25, 710))
#         screen.blit(p2_surf, p2_rect)

#     def run(self):
#         while True:
#             for event in pygame.event.get():
#                 if event.type == pygame.QUIT:
#                     pygame.quit()
#                     sys.exit()
#                 if event.type == pygame.MOUSEBUTTONDOWN and self.game_state != "game_over":
#                     self.handle_click(self.get_pos_from_mouse(event.pos))
#                 if event.type == pygame.KEYDOWN and event.key == pygame.K_r and self.game_state == "game_over":
#                     self.__init__()
#             self.draw_board()
#             self.draw_pieces()
#             self.draw_status_panel()
#             pygame.display.flip()
#             self.clock.tick(30)


# if __name__ == '__main__':
#     game = Game()
#     game.run()
import pygame
import sys
import math
import os
import random
import copy
from collections import namedtuple

# --- 0. 初始化和常量 (几乎不变) ---

# Pygame 初始化
pygame.init()
pygame.font.init()

# 屏幕设置
SCREEN_WIDTH = 640
SCREEN_HEIGHT = 740
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("搁彡 (AI版)")

# 颜色
COLOR_BOARD = (210, 180, 140)
COLOR_BG = (245, 245, 220)
COLOR_LINE = (0, 0, 0)
COLOR_PLAYER1 = (255, 255, 255)
COLOR_PLAYER2 = (0, 0, 0)
COLOR_HIGHLIGHT = (255, 0, 0)
COLOR_TEXT = (50, 50, 50)
COLOR_BUTTON = (139, 69, 19)
COLOR_BUTTON_HOVER = (160, 82, 45)
COLOR_BUTTON_TEXT = (255, 255, 255)

# 字体处理
FONT_CN_PATH = "simhei.ttf"
if sys.platform == "win32":
    font_path_system = os.path.join(os.environ.get("SystemRoot", "C:/Windows"), "Fonts", FONT_CN_PATH)
    if os.path.exists(font_path_system):
        FONT_CN_PATH = font_path_system

try:
    FONT_LARGE_CN = pygame.font.Font(FONT_CN_PATH, 40)
    FONT_STATUS_CN = pygame.font.Font(FONT_CN_PATH, 26)
    FONT_INFO_CN = pygame.font.Font(FONT_CN_PATH, 20)
except FileNotFoundError:
    print(f"错误：中文字体 '{FONT_CN_PATH}' 未找到！将使用备用字体。")
    FONT_LARGE_CN = pygame.font.SysFont('Arial', 40)
    FONT_STATUS_CN = pygame.font.SysFont('Arial', 30)
    FONT_INFO_CN = pygame.font.SysFont('Arial', 24)

# 游戏常量
PIECE_RADIUS = 16
CLICK_RADIUS = 25

# 游戏规则数据结构 (不变)
POSITIONS = [
    'O1', 'O2', 'O3', 'O4', 'O5', 'O6', 'O7', 'O8', 'M1', 'M2', 'M3', 'M4', 'M5', 'M6', 'M7', 'M8',
    'I1', 'I2', 'I3', 'I4', 'I5', 'I6', 'I7', 'I8',
]
COORDS = {
    'O1': (70, 70), 'O2': (320, 70), 'O3': (570, 70), 'O4': (570, 320), 'O5': (570, 570), 'O6': (320, 570),
    'O7': (70, 570), 'O8': (70, 320), 'M1': (170, 170), 'M2': (320, 170), 'M3': (470, 170), 'M4': (470, 320),
    'M5': (470, 470), 'M6': (320, 470), 'M7': (170, 470), 'M8': (170, 320), 'I1': (250, 250), 'I2': (320, 250),
    'I3': (390, 250), 'I4': (390, 320), 'I5': (390, 390), 'I6': (320, 390), 'I7': (250, 390), 'I8': (250, 320),
}
ADJACENCY = {
    'O1': ['O2', 'O8', 'M1'], 'O2': ['O1', 'O3', 'M2'], 'O3': ['O2', 'O4', 'M3'], 'O4': ['O3', 'O5', 'M4'],
    'O5': ['O4', 'O6', 'M5'], 'O6': ['O5', 'O7', 'M6'], 'O7': ['O6', 'O8', 'M7'], 'O8': ['O7', 'O1', 'M8'],
    'M1': ['M2', 'M8', 'O1', 'I1'], 'M2': ['M1', 'M3', 'O2', 'I2'], 'M3': ['M2', 'M4', 'O3', 'I3'],
    'M4': ['M3', 'M5', 'O4', 'I4'], 'M5': ['M4', 'M6', 'O5', 'I5'], 'M6': ['M5', 'M7', 'O6', 'I6'],
    'M7': ['M6', 'M8', 'O7', 'I7'], 'M8': ['M7', 'M1', 'O8', 'I8'], 'I1': ['I2', 'I8', 'M1'],
    'I2': ['I1', 'I3', 'M2'], 'I3': ['I2', 'I4', 'M3'], 'I4': ['I3', 'I5', 'M4'], 'I5': ['I4', 'I6', 'M5'],
    'I6': ['I5', 'I7', 'M6'], 'I7': ['I6', 'I8', 'M7'], 'I8': ['I7', 'I1', 'M8']
}
MILLS = [
    ['O1', 'O2', 'O3'], ['O3', 'O4', 'O5'], ['O5', 'O6', 'O7'], ['O7', 'O8', 'O1'], ['M1', 'M2', 'M3'],
    ['M3', 'M4', 'M5'], ['M5', 'M6', 'M7'], ['M7', 'M8', 'M1'], ['I1', 'I2', 'I3'], ['I3', 'I4', 'I5'],
    ['I5', 'I6', 'I7'], ['I7', 'I8', 'I1'], ['O2', 'M2', 'I2'], ['O4', 'M4', 'I4'], ['O6', 'M6', 'I6'],
    ['O8', 'M8', 'I8'], ['O1', 'M1', 'I1'], ['O3', 'M3', 'I3'], ['O5', 'M5', 'I5'], ['O7', 'M7', 'I7']
]

# --- 1. 【新增】AI 玩家类 (AI Player Class) ---
class AIPlayer:
    """封装AI决策逻辑的类，与游戏显示分离。"""
    def __init__(self, player_num, search_depth=3):
        self.player_num = player_num
        self.opponent_num = 3 - player_num
        self.search_depth = search_depth

    def find_best_move(self, game):
        """AI决策的入口点，返回一个包含最佳走法的字典。"""
        board_copy = game.board.copy()
        pieces_to_place_copy = game.pieces_to_place.copy()

        # 如果AI需要移除棋子
        if game.game_state == "remove":
            return self._find_best_removal(board_copy)

        # 否则，使用minimax寻找最佳放置或移动
        _, best_move = self.minimax(
            board_copy, self.search_depth, float('-inf'), float('inf'), True,
            game.phase, pieces_to_place_copy
        )
        return best_move

    def _find_best_removal(self, board):
        """找到移除哪个子价值最高"""
        possible_removals = [
            pos for pos, player in board.items()
            if player == self.opponent_num and not self._is_in_a_mill(board, pos, self.opponent_num)
        ]
        if not possible_removals: # 如果所有对手棋子都在磨坊里，则无法移除
            return None
        
        # 策略：简单地移除第一个能移除的。可以扩展为更复杂的逻辑。
        # 例如：优先移除能破坏对方潜在磨坊的棋子。
        return {'action': 'remove', 'pos': random.choice(possible_removals)}

    def minimax(self, board, depth, alpha, beta, is_maximizing, phase, pieces_to_place):
        if depth == 0 or self._is_game_over(board, phase):
            return self.evaluate_board(board), None

        possible_moves = self._get_all_possible_moves(board, is_maximizing, phase, pieces_to_place)
        
        best_move = random.choice(possible_moves) if possible_moves else None
        
        if is_maximizing:
            max_eval = float('-inf')
            for move in possible_moves:
                new_board, new_phase, new_pieces_to_place = self._make_move(board, move, self.player_num, phase, pieces_to_place)
                evaluation, _ = self.minimax(new_board, depth - 1, alpha, beta, False, new_phase, new_pieces_to_place)
                if evaluation > max_eval:
                    max_eval = evaluation
                    best_move = move
                alpha = max(alpha, evaluation)
                if beta <= alpha:
                    break
            return max_eval, best_move
        else: # Minimizing
            min_eval = float('inf')
            for move in possible_moves:
                new_board, new_phase, new_pieces_to_place = self._make_move(board, move, self.opponent_num, phase, pieces_to_place)
                evaluation, _ = self.minimax(new_board, depth - 1, alpha, beta, True, new_phase, new_pieces_to_place)
                if evaluation < min_eval:
                    min_eval = evaluation
                    best_move = move
                beta = min(beta, evaluation)
                if beta <= alpha:
                    break
            return min_eval, best_move

    def evaluate_board(self, board):
        """启发式评估函数，评估棋盘局势分数。"""
        ai_pieces = sum(1 for p in board.values() if p == self.player_num)
        opponent_pieces = sum(1 for p in board.values() if p == self.opponent_num)

        if opponent_pieces < 3: return 1000  # AI赢了
        if ai_pieces < 3: return -1000 # AI输了

        ai_mills = sum(1 for mill in MILLS if all(board.get(pos) == self.player_num for pos in mill))
        opponent_mills = sum(1 for mill in MILLS if all(board.get(pos) == self.opponent_num for pos in mill))
        
        score = 0
        score += (ai_pieces - opponent_pieces) * 10
        score += (ai_mills - opponent_mills) * 25
        # 还可以增加对棋子机动性(mobility)的评估
        return score

    def _get_all_possible_moves(self, board, is_maximizing, phase, pieces_to_place):
        player = self.player_num if is_maximizing else self.opponent_num
        moves = []
        if phase == 1:
            if pieces_to_place[player] > 0:
                empty_spots = [pos for pos, p_val in board.items() if p_val == 0]
                for pos in empty_spots:
                    moves.append({'action': 'place', 'pos': pos})
        else: # phase 2
            player_pieces = [pos for pos, p_val in board.items() if p_val == player]
            for pos in player_pieces:
                for neighbor in ADJACENCY[pos]:
                    if board[neighbor] == 0:
                        moves.append({'action': 'move', 'from': pos, 'to': neighbor})
        return moves
    
    def _make_move(self, board, move, player, phase, pieces_to_place):
        """在虚拟棋盘上执行一步，返回新状态"""
        new_board = board.copy()
        new_pieces_to_place = pieces_to_place.copy()
        
        if move['action'] == 'place':
            new_board[move['pos']] = player
            new_pieces_to_place[player] -= 1
        elif move['action'] == 'move':
            new_board[move['from']] = 0
            new_board[move['to']] = player
        
        # 如果形成磨坊，模拟移除一个对方棋子
        pos_moved_to = move.get('pos') or move.get('to')
        if self._check_mill(new_board, pos_moved_to, player):
            opponent_removable = [
                p for p, owner in new_board.items() 
                if owner == (3 - player) and not self._is_in_a_mill(new_board, p, 3 - player)
            ]
            if opponent_removable:
                # 简单策略：移除对方一个随机的非磨坊棋子
                piece_to_remove = random.choice(opponent_removable)
                new_board[piece_to_remove] = 0

        new_phase = 2 if all(p == 0 for p in new_pieces_to_place.values()) else 1
        return new_board, new_phase, new_pieces_to_place

    def _is_in_a_mill(self, board, pos, player):
        for mill in MILLS:
            if pos in mill and all(board.get(p) == player for p in mill):
                return True
        return False
    
    def _check_mill(self, board, pos, player):
        if not pos: return False
        return self._is_in_a_mill(board, pos, player)
        
    def _is_game_over(self, board, phase):
        if phase != 2: return False
        p1_count = sum(1 for v in board.values() if v == 1)
        p2_count = sum(1 for v in board.values() if v == 2)
        if p1_count < 3 or p2_count < 3: return True
        return False

# --- 2. 游戏主类 (Main Game Class) ---
class Game:
    """封装游戏主逻辑和 Pygame 显示"""
    def __init__(self, game_mode='pvp'):
        self.board = {pos: 0 for pos in POSITIONS}
        self.phase = 1
        self.turn = 1
        self.pieces_to_place = {1: 12, 2: 12}
        self.game_state = "place"  # place, remove, move_select, move_place, game_over
        self.selected_piece_pos = None
        self.message = ""
        self.newly_formed_mill = []
        self.clock = pygame.time.Clock()

        # 【新增】游戏模式和AI玩家
        self.game_mode = game_mode
        self.ai_player = AIPlayer(player_num=2) if self.game_mode == 'pve' else None
        
        self.update_message()

    # ... (get_piece_counts 和 update_message 保持基本不变, 但提示信息可微调)
    def get_piece_counts(self):
        p1_count = sum(1 for v in self.board.values() if v == 1)
        p2_count = sum(1 for v in self.board.values() if v == 2)
        return p1_count, p2_count

    def update_message(self):
        p1_name = "您" if self.game_mode == 'pve' else "白方 (玩家1)"
        p2_name = "电脑" if self.game_mode == 'pve' else "黑方 (玩家2)"
        player_name = p1_name if self.turn == 1 else p2_name

        if self.game_state == "place":
            self.message = f"轮到{player_name}: 请放置棋子。剩余: {self.pieces_to_place[self.turn]}"
        elif self.game_state == "remove":
            self.message = f"{player_name}三连已成！请选择一个对方棋子进行“薅”子！"
        elif self.game_state == "move_select":
            self.message = f"轮到{player_name}: 请选择要移动的己方棋子。"
        elif self.game_state == "move_place":
            self.message = f"轮到{player_name}: 请选择一个相邻的空位。"
        elif self.game_state == "game_over":
            winner_name = p1_name if self.turn == 1 else p2_name # 胜利者是当前回合的玩家
            self.message = f"游戏结束！{winner_name}胜利！按 'R' 重新开始。"

    # 游戏逻辑函数基本不变
    def switch_turn(self):
        self.turn = 3 - self.turn
        self.newly_formed_mill = []
        if self.phase == 1 and all(p == 0 for p in self.pieces_to_place.values()):
            self.phase = 2
            for pos, val in self.board.items():
                if val == -1: self.board[pos] = 0
            self.turn = 2 # Phase 2 Player 2 (or AI) starts
            self.game_state = "move_select"
        elif self.phase == 2:
             if self.check_win_condition(): return
             if self.check_stalemate():
                 winner_name = "白方" if self.turn == 2 else "黑方"
                 self.game_state = "game_over"
                 self.message = f"游戏结束！{winner_name}胜利 (对手已无路可走)！按 'R' 重新开始。"
                 return
        self.update_message()

    def get_pos_from_mouse(self, mouse_pos):
        for pos_id, coord in COORDS.items():
            if math.hypot(mouse_pos[0] - coord[0], mouse_pos[1] - coord[1]) <= CLICK_RADIUS:
                return pos_id
        return None

    def check_mill(self, pos, player):
        for mill in MILLS:
            if pos in mill and all(self.board.get(p) == player for p in mill):
                return True
        return False

    def is_in_a_mill(self, pos):
        player = self.board[pos]
        if player == 0: return False
        for mill in MILLS:
            if pos in mill and all(self.board.get(p) == player for p in mill):
                return True
        return False

    def check_win_condition(self):
        if self.phase != 2: return False
        p1_count, p2_count = self.get_piece_counts()
        if p1_count < 3 or p2_count < 3:
            self.game_state = "game_over"
            self.update_message()
            return True
        return False
    
    def check_stalemate(self):
        if self.phase != 2: return False
        for pos, player in self.board.items():
            if player == self.turn:
                for neighbor in ADJACENCY[pos]:
                    if self.board[neighbor] == 0:
                        return False
        return True

    def has_valid_capture_target(self):
        opponent = 3 - self.turn
        non_mill_pieces = [pos for pos, p in self.board.items() if p == opponent and not self.is_in_a_mill(pos)]
        return len(non_mill_pieces) > 0

    def handle_click(self, pos_id):
        # AI回合中，忽略玩家点击
        if self.game_mode == 'pve' and self.turn == self.ai_player.player_num:
            return
            
        if not pos_id: return
        
        current_player = self.turn
        
        if self.game_state == "place":
            if self.board[pos_id] == 0:
                self.board[pos_id] = current_player
                self.pieces_to_place[current_player] -= 1
                if self.check_mill(pos_id, current_player):
                    if self.has_valid_capture_target(): self.game_state = "remove"
                    else: self.switch_turn()
                else: self.switch_turn()
        
        elif self.game_state == "remove":
            opponent = 3 - current_player
            if self.board.get(pos_id) == opponent and not self.is_in_a_mill(pos_id):
                self.board[pos_id] = -1 if self.phase == 1 else 0
                if not self.check_win_condition():
                     self.game_state = "place" if self.phase == 1 else "move_select"
                     self.switch_turn()
        
        elif self.game_state == "move_select":
            if self.board[pos_id] == current_player:
                self.selected_piece_pos = pos_id
                self.game_state = "move_place"
        
        elif self.game_state == "move_place":
            if self.board[pos_id] == current_player:
                self.selected_piece_pos = pos_id # 允许重新选择
            elif self.board[pos_id] == 0 and pos_id in ADJACENCY.get(self.selected_piece_pos, []):
                self.board[self.selected_piece_pos] = 0
                self.board[pos_id] = current_player
                if self.check_mill(pos_id, current_player):
                    if self.has_valid_capture_target(): self.game_state = "remove"
                    else: self.switch_turn()
                else: self.switch_turn()
                self.selected_piece_pos = None
            else: # 点击无效位置，返回选择棋子状态
                 self.selected_piece_pos = None
                 self.game_state = "move_select"
        self.update_message()

    # 【新增】处理AI行动的方法
    def handle_ai_turn(self):
        move = self.ai_player.find_best_move(self)
        
        if not move: # AI无棋可走
            return

        print(f"AI decision: {move}") # 在控制台打印AI决策，便于调试

        action = move['action']
        if action == 'place':
            pos = move['pos']
            self.board[pos] = self.ai_player.player_num
            self.pieces_to_place[self.ai_player.player_num] -= 1
            if self.check_mill(pos, self.ai_player.player_num):
                 self.game_state = "remove"
            else:
                 self.switch_turn()

        elif action == 'move':
            self.board[move['from']] = 0
            self.board[move['to']] = self.ai_player.player_num
            if self.check_mill(move['to'], self.ai_player.player_num):
                self.game_state = "remove"
            else:
                self.switch_turn()
        
        elif action == 'remove':
            self.board[move['pos']] = -1 if self.phase == 1 else 0
            if not self.check_win_condition():
                self.game_state = "place" if self.phase == 1 else "move_select"
                self.switch_turn()
        
        self.update_message()

    # 绘图函数保持不变
    def draw_board(self):
        screen.fill(COLOR_BG)
        pygame.draw.rect(screen, COLOR_BOARD, (20, 20, 600, 600))
        pygame.draw.rect(screen, COLOR_LINE, (70, 70, 500, 500), 4)
        pygame.draw.rect(screen, COLOR_LINE, (170, 170, 300, 300), 4)
        pygame.draw.rect(screen, COLOR_LINE, (250, 250, 140, 140), 4)
        # 绘制所有连接线
        lines_drawn = set()
        for pos, neighbors in ADJACENCY.items():
            for neighbor in neighbors:
                line_id = tuple(sorted((pos, neighbor)))
                if line_id not in lines_drawn:
                    pygame.draw.line(screen, COLOR_LINE, COORDS[pos], COORDS[neighbor], 4)
                    lines_drawn.add(line_id)

    def draw_pieces(self):
        for pos_id, coord in COORDS.items():
            player = self.board[pos_id]
            if player == 1:
                pygame.draw.circle(screen, COLOR_PLAYER1, coord, PIECE_RADIUS)
                pygame.draw.circle(screen, COLOR_LINE, coord, PIECE_RADIUS, 2) # 加个边框更好看
            elif player == 2:
                pygame.draw.circle(screen, COLOR_PLAYER2, coord, PIECE_RADIUS)
            elif player == -1:
                pygame.draw.line(screen, COLOR_HIGHLIGHT, (coord[0]-10, coord[1]-10), (coord[0]+10, coord[1]+10), 4)
                pygame.draw.line(screen, COLOR_HIGHLIGHT, (coord[0]+10, coord[1]-10), (coord[0]-10, coord[1]+10), 4)
            if self.selected_piece_pos == pos_id:
                pygame.draw.circle(screen, COLOR_HIGHLIGHT, coord, PIECE_RADIUS + 4, 4)

    def draw_status_panel(self):
        pygame.draw.rect(screen, COLOR_BOARD, (0, 640, SCREEN_WIDTH, 100))
        text_surface = FONT_STATUS_CN.render(self.message, True, COLOR_TEXT)
        text_rect = text_surface.get_rect(center=(SCREEN_WIDTH / 2, 670))
        screen.blit(text_surface, text_rect)

        p1_count, p2_count = self.get_piece_counts()
        p1_info_text = f"白方棋子: {p1_count}" if self.phase == 2 else f"白方待放: {self.pieces_to_place[1]}"
        p2_info_text = f"黑方棋子: {p2_count}" if self.phase == 2 else f"黑方待放: {self.pieces_to_place[2]}"
        
        p1_surf = FONT_INFO_CN.render(p1_info_text, True, COLOR_TEXT)
        screen.blit(p1_surf, (25, 710))
        
        p2_surf = FONT_INFO_CN.render(p2_info_text, True, COLOR_TEXT)
        p2_rect = p2_surf.get_rect(topright=(SCREEN_WIDTH - 25, 710))
        screen.blit(p2_surf, p2_rect)

    def run(self):
        running = True
        while running:
            is_ai_turn = self.game_mode == 'pve' and self.turn == self.ai_player.player_num and self.game_state != "game_over"

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                if event.type == pygame.MOUSEBUTTONDOWN and not is_ai_turn:
                    self.handle_click(self.get_pos_from_mouse(event.pos))
                if event.type == pygame.KEYDOWN and event.key == pygame.K_r:
                    # 重启功能现在需要返回到主菜单，所以这里只退出当前游戏循环
                    running = False 
            
            if is_ai_turn:
                pygame.time.wait(500) # 给AI一点思考时间，提升体验
                self.handle_ai_turn()

            self.draw_board()
            self.draw_pieces()
            self.draw_status_panel()
            pygame.display.flip()
            self.clock.tick(30)

# --- 3. 【新增】主菜单函数和主程序入口 ---
def main_menu():
    """显示游戏主菜单，并返回选择的游戏模式。"""
    button_pve = pygame.Rect(SCREEN_WIDTH/2 - 150, 250, 300, 60)
    button_pvp = pygame.Rect(SCREEN_WIDTH/2 - 150, 350, 300, 60)
    
    while True:
        screen.fill(COLOR_BG)
        
        title_text = FONT_LARGE_CN.render("搁彡", True, COLOR_TEXT)
        title_rect = title_text.get_rect(center=(SCREEN_WIDTH/2, 150))
        screen.blit(title_text, title_rect)

        mouse_pos = pygame.mouse.get_pos()
        
        # 绘制PVE按钮
        pve_color = COLOR_BUTTON_HOVER if button_pve.collidepoint(mouse_pos) else COLOR_BUTTON
        pygame.draw.rect(screen, pve_color, button_pve, border_radius=15)
        pve_text = FONT_STATUS_CN.render("玩家 vs 电脑", True, COLOR_BUTTON_TEXT)
        screen.blit(pve_text, pve_text.get_rect(center=button_pve.center))

        # 绘制PVP按钮
        pvp_color = COLOR_BUTTON_HOVER if button_pvp.collidepoint(mouse_pos) else COLOR_BUTTON
        pygame.draw.rect(screen, pvp_color, button_pvp, border_radius=15)
        pvp_text = FONT_STATUS_CN.render("玩家 vs 玩家", True, COLOR_BUTTON_TEXT)
        screen.blit(pvp_text, pvp_text.get_rect(center=button_pvp.center))
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            if event.type == pygame.MOUSEBUTTONDOWN:
                if button_pve.collidepoint(mouse_pos):
                    return 'pve'
                if button_pvp.collidepoint(mouse_pos):
                    return 'pvp'
        
        pygame.display.flip()


if __name__ == '__main__':
    while True: # 允许游戏结束后返回主菜单
        game_mode = main_menu()
        game = Game(game_mode)
        game.run()
    # pyinstaller --name NineMensMorris --windowed --add-data "simhei.ttf;." --upx-dir "D:/software/upx/upx-5.0.1-win64" morris_game.py
